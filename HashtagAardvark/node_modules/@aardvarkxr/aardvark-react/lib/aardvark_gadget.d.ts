import * as React from 'react';
import { AvStartGadgetCallback, AvActionState, EAction } from '@aardvarkxr/aardvark-shared';
import { IAvBaseNode } from './aardvark_base_node';
import { CGadgetEndpoint } from './gadget_endpoint';
import { MessageType, EndpointAddr, MsgGrabEvent, MsgGadgetStarted, AvGadgetManifest, AvPanelHandler, PokerProximity, AvPanelMouseEventType, AvGrabEventProcessor, AvGrabEvent, EHand } from '@aardvarkxr/aardvark-shared';
export interface AvPokerHandler {
    (isPressed: boolean, proximity: PokerProximity[]): void;
}
interface ActionStateListener {
    hand: EHand;
    action: EAction;
    rising?: () => void;
    falling?: () => void;
}
/** The singleton gadget object for the browser. */
export declare class AvGadget {
    private static s_instance;
    m_onSettingsReceived: (settings: any) => void;
    m_nextNodeId: number;
    m_registeredNodes: {
        [nodeId: number]: IAvBaseNode;
    };
    m_nextFrameRequest: number;
    m_traversedNodes: {
        [nodeId: number]: IAvBaseNode;
    };
    m_endpoint: CGadgetEndpoint;
    m_manifest: AvGadgetManifest;
    m_actualGadgetUri: string;
    m_actionState: {
        [hand: number]: AvActionState;
    };
    private m_persistenceUuid;
    private m_epToNotify;
    private m_firstSceneGraph;
    private m_mainGrabbable;
    private m_mainHandle;
    private m_mainGrabbableComponent;
    private m_mainHandleComponent;
    m_grabEventProcessors: {
        [nodeId: number]: AvGrabEventProcessor;
    };
    m_pokerProcessors: {
        [nodeId: number]: AvPokerHandler;
    };
    m_panelProcessors: {
        [nodeId: number]: AvPanelHandler;
    };
    m_startGadgetCallbacks: {
        [nodeId: number]: AvStartGadgetCallback;
    };
    m_actionStateListeners: {
        [listenerId: number]: ActionStateListener;
    };
    constructor();
    onEndpointOpen(settings: any, persistenceUuid: string): void;
    /** Returns the AvGadget singleton.
     *
     * @public
     */
    static instance(): AvGadget;
    /** Returns the name of the gadget.
     *
     * @public
    */
    getName(): string;
    /** Loads a gadget manifest by gadget URI.
     *
     * @returns a promise that will resolve to the specified gadget's manifest
     * @public
     */
    loadManifest(gadgetUri: string): Promise<AvGadgetManifest>;
    /** Returns a list of all the installed gadget's URIs.
     *
     * @public
    */
    getInstalledGadgets(): Promise<string[]>;
    register(node: IAvBaseNode): void;
    unregister(node: IAvBaseNode): void;
    setPanelHandler(nodeId: number, handler: AvPanelHandler): void;
    setPokerHandler(nodeId: number, handler: AvPokerHandler): void;
    setGrabEventProcessor(nodeId: number, processor: AvGrabEventProcessor): void;
    getEndpointId(): number;
    onGrabEvent(type: MessageType, m: MsgGrabEvent, sender: EndpointAddr, target: EndpointAddr): void;
    onGadgetStarted(type: MessageType, m: MsgGadgetStarted, sender: EndpointAddr, target: EndpointAddr): void;
    sendGrabEvent(event: AvGrabEvent): void;
    private onPokerProximity;
    sendMouseEvent(pokerId: EndpointAddr, panelId: EndpointAddr, eventType: AvPanelMouseEventType, x: number, y: number): void;
    private onMouseEvent;
    private onMasterStartGadget;
    private onResourceLoadFailed;
    listenForActionState(action: EAction, hand: EHand, rising: () => void, falling: () => void): number;
    listenForActionStateWithComponent(hand: EHand, action: EAction, comp: React.Component): number;
    unlistenForActionState(handle: number): void;
    private onUpdateActionState;
    /** Returns true if the gadget is in edit mode for the
     * specified hand.
     *
     * @public
     */
    getActionStateForHand(hand: EHand, action: EAction): boolean;
    private traverseNode;
    updateSceneGraph(): void;
    markDirty(): void;
    sendHapticEvent(nodeId: EndpointAddr, amplitude: number, frequency: number, duration: number): void;
    startGadget(uri: string, initialHook: string, callback: AvStartGadgetCallback): void;
    /** Persists the gadget's settings. These weill be passed to the gadget
     * via the callback registered with registerForSettings whenever the
     * gadget is reloaded.
     * @public
     */
    saveSettings(settings: any): void;
    /** The callback registered with this function will be invoked when
     * the gadget's settings are reloaded from the server.
     * @public
     */
    registerForSettings(callback: (settings: any) => void): void;
    /** Returns the endpoint address for a DOM node Id, or null if there
     * isn't a matching Aardvark node with that Id.
     */
    getEndpointAddressForId(id: string): EndpointAddr;
}
export {};
//# sourceMappingURL=aardvark_gadget.d.ts.map